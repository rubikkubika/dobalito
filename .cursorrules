# Cursor Rules for Dobalito Project

## 💻 Terminal/Shell Rules (CRITICAL - ALWAYS ENFORCE)
**🔴 MANDATORY: ALWAYS use Git Bash for ALL terminal commands on Windows**
**🔴 NEVER use PowerShell commands (tasklist, findstr, $env:, etc.)**

### Required shell usage:
- ✅ **MANDATORY**: Use Git Bash: `C:\Program Files\Git\bin\bash.exe` (ONLY shell allowed)
- ✅ Git Bash commands with proper Unix syntax (ps, grep, curl, etc.)
- ✅ Environment variables: `VARIABLE=value` (not `$env:VARIABLE`)
- ✅ Command chaining: `&&` (not `;` from PowerShell)
- ✅ Background processes: `command &` (not `is_background: true`)
- ❌ **NEVER** use PowerShell commands: `tasklist`, `findstr`, `$env:`, `Get-Process`
- ❌ **NEVER** use `$env:VARIABLE` syntax
- ❌ **NEVER** use PowerShell-specific cmdlets
- ❌ **NEVER** use Windows CMD commands without Git Bash wrapper

### Git Bash command examples:
```bash
# Backend start (Git Bash)
cd backend && \
SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/dobalito" \
SPRING_DATASOURCE_USERNAME="postgres" \
SPRING_DATASOURCE_PASSWORD="root" \
mvn spring-boot:run &

# Frontend start (Git Bash)
cd frontend-react && npm start &

# Check processes
ps aux | grep -E 'java|node' | grep -v grep

# Port check
netstat -ano | grep ':8080\|:3000\|:3001'

# API check
curl --max-time 10 http://localhost:8080/api/v1/health
```

### Enforcement (AI Assistant MUST follow):
- 🔴 **CRITICAL**: EVERY terminal command MUST use Git Bash wrapper
- 🔴 **CRITICAL**: If you catch yourself typing `tasklist`, `findstr`, `$env:` - STOP and use Git Bash
- ✅ ALWAYS execute commands through Git Bash: `& "C:\Program Files\Git\bin\bash.exe" -c "command"`
- ✅ ALWAYS use Unix-style commands: `ps`, `grep`, `curl`, `kill`
- ✅ ALWAYS use proper bash syntax for env variables: `VARIABLE=value`
- ❌ NEVER use PowerShell native commands without Git Bash wrapper
- ❌ NEVER switch to PowerShell (even if it seems easier)
- ❌ NEVER assume PowerShell is acceptable alternative

### Git Bash invocation in terminal commands:
```bash
# ✅ CORRECT: Always use Git Bash wrapper for ALL commands
& "C:\Program Files\Git\bin\bash.exe" -c "ps aux | grep java"
& "C:\Program Files\Git\bin\bash.exe" -c "netstat -ano | grep 8080"
& "C:\Program Files\Git\bin\bash.exe" -c "curl --max-time 10 http://localhost:8080/api/v1/health"

# ❌ WRONG: Never use PowerShell commands directly
# tasklist | findstr java.exe  # ← FORBIDDEN
# netstat -ano | findstr :8080  # ← FORBIDDEN
# $env:VARIABLE="value"  # ← FORBIDDEN
```

### Git Bash command replacements (MANDATORY):
- `tasklist` → `& "C:\Program Files\Git\bin\bash.exe" -c "ps aux"`
- `findstr` → `& "C:\Program Files\Git\bin\bash.exe" -c "grep"`
- `netstat -ano | findstr` → `& "C:\Program Files\Git\bin\bash.exe" -c "netstat -ano | grep"`
- `Get-Process` → `& "C:\Program Files\Git\bin\bash.exe" -c "ps aux"`
- `$env:VAR` → Use Git Bash: `VARIABLE=value command`

## 🐳 Docker Files Organization (STRICT RULE)
**ALL Docker-related files MUST be placed in the `docker/` directory**

### Required Placement:
- ✅ `docker/docker-compose.yml` - Main compose file
- ✅ `docker/Dockerfile.frontend` - Frontend Dockerfile  
- ✅ `docker/Dockerfile.backend` - Backend Dockerfile
- ✅ `docker/Dockerfile.fullstack` - Full-stack Dockerfile
- ✅ `docker/nginx.conf` - Nginx configuration
- ✅ `docker/*.sh` - Docker scripts

### Forbidden Placement:
- ❌ `docker-compose.yml` (in root)
- ❌ `Dockerfile` (in root)
- ❌ `nginx.conf` (in root)
- ❌ Any Docker files outside `docker/` directory

## 📁 Project Structure Rules
- Keep Docker configurations centralized in `docker/` folder
- Use `docker/` as build context for Docker operations
- Maintain consistency with existing Docker file organization
- Reference Docker files with paths relative to `docker/` directory

## 🔧 Build Context Guidelines
When creating Docker configurations:
- Build context: `docker/` directory
- Dockerfile paths: `docker/Dockerfile.*`
- Compose file paths: `docker/docker-compose.*`

## 📝 File Naming Conventions
- Docker Compose: `docker-compose.yml`, `docker-compose.*.yml`
- Dockerfiles: `Dockerfile`, `Dockerfile.*`
- Config files: descriptive names (`nginx.conf`, `postgres.conf`)

## ⚠️ Enforcement
- Always place new Docker files in `docker/` directory
- Update build contexts when referencing Docker files
- Maintain existing Docker file organization patterns

## 🌐 HTTP Client Rules
**ALWAYS use timeout with curl commands**

### Required curl usage:
- ✅ `curl.exe --max-time 10 -s http://localhost:3001` (Windows PowerShell)
- ✅ `curl --max-time 10 -s http://localhost:3001` (Linux/Mac)
- ✅ `curl.exe --connect-timeout 5 --max-time 10 -s http://localhost:8080/api/v1/health`
- ❌ `curl http://localhost:3001` (no timeout)
- ❌ `curl -s http://localhost:3001` (no timeout)

### Timeout guidelines:
- `--connect-timeout 5` - Connection timeout (5 seconds)
- `--max-time 10` - Total timeout (10 seconds)
- Always use `-s` for silent mode
- Use `-f` for fail on HTTP errors when needed
- On Windows PowerShell, use `curl.exe` instead of `curl`

## 🔄 Service Restart Rules
**ALWAYS check what's running first, then restart accordingly**

### MANDATORY restart sequence (NEVER skip steps):
1. **Check local processes**: 
   - Windows: `tasklist | findstr java.exe` AND `tasklist | findstr node.exe`
   - Linux/Mac: `ps aux | grep java` AND `ps aux | grep node`
2. **Check Docker containers**: `docker-compose -f docker/docker-compose.yml ps`
3. **Check port usage**: `netstat -ano | findstr :8080` (Windows) or `lsof -i :8080` (Linux/Mac)
4. **Stop ALL conflicting processes**:
   - If restarting locally: `docker-compose -f docker/docker-compose.yml down`
   - If restarting via Docker: `taskkill /f /im java.exe` AND `taskkill /f /im node.exe`
5. **Start services based on request**:
   - For local backend restart: Create local DB + `cd backend; $env:SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/dobalito"; $env:SPRING_DATASOURCE_USERNAME="postgres"; $env:SPRING_DATASOURCE_PASSWORD="root"; mvn spring-boot:run`
   - For Docker restart: `docker-compose -f docker/docker-compose.yml up -d`
6. **MANDATORY verification**: 
   - Wait 15-20 seconds for startup
   - Test with curl: `curl.exe --max-time 10 -s http://localhost:8080/api/v1/health`
   - Verify port is listening: `netstat -ano | findstr :8080`

### Context-aware restart:
- **"запусти бэк локально"** → Stop Docker, start locally with Maven + local DB
- **"запусти фронт локально"** → Stop Docker, start locally with npm
- **"перезапусти сервисы через docker"** → Stop local processes, start Docker
- **"перезапусти сервисы"** → Check what's running, restart accordingly

## 🏠 Local Backend Database Rules
**When user requests "запустить бэк локально" or "запустить бэкенд локально":**

### MANDATORY local database setup:
1. **ALWAYS use local PostgreSQL database `dobalito`**
2. **Connection string**: `jdbc:postgresql://localhost:5432/dobalito`
3. **Credentials**: username=`postgres`, password=`root`
4. **Create database if not exists**:
   ```bash
   $env:PGPASSWORD="root"; & "C:\Program Files\PostgreSQL\18\bin\psql.exe" -U postgres -h localhost -c "CREATE DATABASE dobalito;"
   ```
5. **Start backend with local DB**:
   ```bash
   cd backend; $env:SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/dobalito"; $env:SPRING_DATASOURCE_USERNAME="postgres"; $env:SPRING_DATASOURCE_PASSWORD="root"; mvn spring-boot:run
   ```

### CRITICAL requirements:
- ✅ ALWAYS create `dobalito` database if it doesn't exist
- ✅ ALWAYS use local PostgreSQL (not Docker database)
- ✅ ALWAYS set environment variables for local DB connection
- ✅ ALWAYS run Maven from backend directory
- ✅ ALWAYS verify local database connection before starting
- ❌ NEVER use Docker database for local backend runs
- ❌ NEVER assume database exists without checking/creating

### CRITICAL requirements:
- ✅ ALWAYS check BOTH Java AND Node processes
- ✅ ALWAYS check Docker containers status
- ✅ ALWAYS check port conflicts (8080, 3000, 3001)
- ✅ ALWAYS stop conflicting processes BEFORE starting
- ✅ ALWAYS wait for startup completion (15-20 seconds)
- ✅ ALWAYS verify with curl requests
- ✅ ALWAYS confirm port is listening
- ❌ NEVER assume services are running without verification
- ❌ NEVER skip process checking steps
- ❌ NEVER start services without stopping conflicts first

### Maven/Node.js specific rules:
- **Maven commands**: Run from current directory (assumes backend/ is current)
- **PowerShell syntax**: Use `;` instead of `&&` for command chaining
- **Background processes**: Use `is_background: true` for long-running commands
- **Error handling**: If Maven fails, check pom.xml and dependencies
- **Port conflicts**: Always verify port 8080 is free before starting backend
- **Directory assumption**: Assume current directory is backend/ when running Maven

### Enforcement:
- MANDATORY: Complete all 6 steps in sequence
- MANDATORY: Verify service availability after each restart
- MANDATORY: Report status clearly to user
- MANDATORY: Follow user's explicit restart preference (local vs Docker)
- MANDATORY: Use correct PowerShell syntax (no `&&` operators)
- MANDATORY: Run Maven from current directory (assume backend/)

## 🚀 Local Development Rules
**ALWAYS run npm start in background to avoid blocking chat**

### Required npm start usage:
- ✅ `npm start` (with is_background: true) - Run in background
- ✅ `Start-Job -ScriptBlock { npm start }` (PowerShell) - Background job
- ✅ `nohup npm start > npm.log 2>&1 &` (Linux/Mac) - Background with logs
- ❌ `npm start` (with is_background: false) - Blocks chat and terminal

### Why background execution:
- ✅ Prevents chat blocking during development
- ✅ Allows continued interaction with assistant
- ✅ Enables parallel command execution
- ✅ Maintains development workflow continuity

### Enforcement:
- NEVER run npm start in foreground mode
- ALWAYS use is_background: true for npm start commands
- ALWAYS verify service availability after background start
- Use Docker as preferred development environment when possible

## 🔧 Local Backend Logging Rules
**Smart backend startup: logs first, then background mode**

### CRITICAL: Backend startup strategy:
- ✅ **FIRST RUN**: Use `is_background: false` to show startup logs and diagnose issues
- ✅ **AFTER SUCCESS**: Switch to `is_background: true` for continued development
- ✅ **ON ERRORS**: Always use `is_background: false` to see error details
- ✅ **MANDATORY**: Show full Spring Boot logs for initial diagnosis
- ✅ **MANDATORY**: Display Flyway migration logs
- ✅ **MANDATORY**: Show JPA/Hibernate startup logs
- ✅ **MANDATORY**: Display database connection logs

### Why this approach works:
- ✅ **Initial diagnosis**: See all startup logs to catch issues early
- ✅ **Interactive development**: Switch to background after successful startup
- ✅ **Error visibility**: Always show logs when problems occur
- ✅ **Development flow**: Maintain chat interactivity during normal development

### Smart backend startup pattern:
```bash
# ✅ STEP 1 - Initial startup with logs (for diagnosis)
run_terminal_cmd
  command: cd backend; $env:SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/dobalito"; $env:SPRING_DATASOURCE_USERNAME="postgres"; $env:SPRING_DATASOURCE_PASSWORD="root"; mvn spring-boot:run
  is_background: false  # ← Show logs for diagnosis

# ✅ STEP 2 - After successful startup, restart in background
run_terminal_cmd
  command: cd backend; $env:SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/dobalito"; $env:SPRING_DATASOURCE_USERNAME="postgres"; $env:SPRING_DATASOURCE_PASSWORD="root"; mvn spring-boot:run
  is_background: true   # ← Background for continued development
```

### Exception: Frontend can always run in background:
```bash
# ✅ OK - Frontend can run in background
run_terminal_cmd
  command: cd frontend-react; npm start
  is_background: true  # ← OK for frontend
```

### Enforcement:
- ALWAYS use `is_background: false` for initial backend startup
- ALWAYS analyze backend logs for errors before proceeding
- ALWAYS switch to `is_background: true` after successful startup
- ALWAYS use `is_background: false` when errors occur
- NEVER hide backend startup logs during initial diagnosis

## 🌍 Internationalization Rules
**ALWAYS update translations for both languages when modifying frontend elements**

### Required i18n workflow:
- ✅ When adding new text elements: Add translations to `LanguageContext.tsx` for both `ru` and `en`
- ✅ When modifying existing text: Update both language versions in `LanguageContext.tsx`
- ✅ When creating new pages: Use `useLanguage()` hook and `t()` function for all text
- ✅ When updating UI components: Ensure all hardcoded text uses translation keys
- ❌ Never add hardcoded Russian/English text directly in components
- ❌ Never update only one language without updating the other

### Translation key structure:
- **Navigation**: `nav.*` (nav.home, nav.profile, nav.settings, nav.designs)
- **Home page**: `home.*` (home.welcome, home.subtitle, home.categories, home.features)
- **Categories**: `category.*` (category.surfing, category.bike_rental)
- **Features**: `feature.*` (feature.create_tasks, feature.find_executors, etc.)
- **Executors**: `executors.*` (executors.title, executors.back, executors.empty)
- **Language selector**: `lang.*` (lang.russian, lang.english)

### Required implementation pattern:
```typescript
// ✅ CORRECT - Using translations
const { t } = useLanguage();
<Typography>{t('home.welcome')}</Typography>

// ❌ WRONG - Hardcoded text
<Typography>Добро пожаловать в doBalito</Typography>
```

### LanguageContext.tsx structure:
```typescript
const translations = {
  ru: {
    'key.name': 'Russian text',
    // ... all Russian translations
  },
  en: {
    'key.name': 'English text',
    // ... all English translations
  },
};
```

### Enforcement:
- ALWAYS add new translation keys to both `ru` and `en` objects
- ALWAYS use `t()` function instead of hardcoded text
- ALWAYS test both language versions when making changes
- ALWAYS maintain consistent translation key naming
- NEVER leave incomplete translations (missing keys in one language)

## 🚫 Service Auto-Start Rules
**NEVER start services automatically without explicit user request**

### Required behavior:
- ✅ Only start services when user explicitly asks (e.g., "запусти сервисы", "start services", "перезапусти")
- ✅ When creating new entities/features: Just create the code, don't start services
- ✅ When adding dependencies: Just update configuration, don't restart
- ✅ When modifying code: Just make changes, don't auto-restart
- ❌ NEVER run `docker-compose up` or `npm start` without user request
- ❌ NEVER restart services after code changes unless asked
- ❌ NEVER assume user wants services running after modifications

### When to start services:
- User says: "запусти сервисы", "start services", "перезапусти"
- User says: "запусти фронт", "start frontend"
- User says: "запусти бэкенд", "start backend"
- User says: "перезапусти через docker", "restart with docker"
- User explicitly requests testing or verification

### When NOT to start services:
- After creating new entities (User, Category, etc.)
- After adding new dependencies
- After modifying existing code
- After creating new controllers/services
- After updating configuration files
- When user just asks to "add" or "create" something

### Enforcement:
- ALWAYS ask user if they want to start services after major changes
- ALWAYS inform user that services are ready but not started
- ALWAYS let user decide when to start/restart services
- NEVER assume user wants immediate service restart
- ALWAYS respect user's development workflow preferences

## 📁 Temporary Files Management Rules
**ALL temporary files MUST be placed in the `temp/` directory**

### Required Placement:
- ✅ `temp/` - All temporary files and folders
- ✅ `temp/debug/` - Debug files and logs
- ✅ `temp/test/` - Test files and outputs
- ✅ `temp/cookies*.txt` - Cookie files
- ✅ `temp/*.log` - Log files
- ✅ `temp/*.tmp` - Temporary files

### Forbidden Placement:
- ❌ Temporary files in project root
- ❌ Temporary files in backend/ or frontend-react/
- ❌ Temporary files in git-tracked directories
- ❌ Log files outside temp/ directory

### Temporary file types:
- **Debug files**: `*.debug`, `*.test`, `*.tmp`
- **Log files**: `*.log`, `*.error.log`, `maven*.log`
- **Cookie files**: `cookies*.txt`, `cookies-after-*.txt`
- **Backup files**: `*.bak`, `*.backup`
- **IDE temp files**: `*.swp`, `*.swo`, `*~`

### Git exclusion:
- All files in `temp/` directory are automatically ignored by git
- Temporary files are never committed to repository
- Clean up temp/ directory regularly

### Enforcement:
- ALWAYS create temporary files in `temp/` directory
- ALWAYS use descriptive subdirectories in `temp/`
- ALWAYS clean up temporary files after debugging
- NEVER commit temporary files to git
- ALWAYS use `temp/` for any development artifacts

## 📚 Documentation Management Rules
**ALL documentation files MUST be placed in the `docs/` directory**

### Required Placement:
- ✅ `docs/` - All documentation files
- ✅ `docs/development/` - Development guides and rules
- ✅ `docs/user-guide/` - User documentation and guides
- ✅ `docs/api/` - API documentation
- ✅ `docs/deployment/` - Deployment guides
- ✅ `docs/architecture/` - System architecture docs

### Forbidden Placement:
- ❌ Documentation files in project root
- ❌ Documentation files in backend/ or frontend-react/
- ❌ README files outside docs/ (except main README.md)
- ❌ Documentation scattered across different directories

### Documentation file types:
- **Guides**: `*.md`, `*.rst`, `*.txt`
- **API docs**: `api-*.md`, `swagger-*.md`
- **Architecture**: `architecture-*.md`, `design-*.md`
- **Deployment**: `deploy-*.md`, `setup-*.md`
- **User guides**: `user-*.md`, `guide-*.md`

### Documentation structure:
```
docs/
├── README.md              # Main documentation index
├── development/           # Development guides
│   ├── development-rules.md
│   ├── local-backend-rule.md
│   └── coding-standards.md
├── user-guide/           # User documentation
│   ├── user-rules.md
│   └── getting-started.md
├── api/                  # API documentation
│   ├── api-reference.md
│   └── endpoints.md
├── deployment/           # Deployment guides
│   ├── docker-deployment.md
│   └── production-setup.md
└── architecture/         # System architecture
    ├── system-overview.md
    └── database-schema.md
```

### Git inclusion:
- All files in `docs/` directory are tracked by git
- Documentation is part of the project repository
- Keep documentation up-to-date with code changes

### Enforcement:
- ALWAYS create documentation files in `docs/` directory
- ALWAYS use appropriate subdirectories in `docs/`
- ALWAYS update documentation when making code changes
- ALWAYS maintain consistent documentation structure
- NEVER create documentation files outside `docs/`
- ALWAYS reference documentation from `docs/` in code comments

## 🔄 Commit Information Update Rules
**ALWAYS update commit information when making commits or PRs to main branch**

### Required commit info updates:
- ✅ Update `commit` file in project root with new 5-character hash
- ✅ Update hardcoded commit hash in `backend/src/main/java/com/dobalito/controller/AppController.java` method `commitInfo()`
- ✅ Update hardcoded commit hash in `frontend-react/src/components/CommitInfo.tsx` component
- ✅ Ensure commit hash is visible on frontend homepage
- ✅ Ensure commit hash is accessible via backend API `/api/v1/info/commit`

### Commit file location:
```
commit  # ← UPDATE THIS FILE with new 5-character hash
```

### Backend commit info location:
```java
@GetMapping("/info/commit")
public ResponseEntity<?> commitInfo() {
    return ResponseEntity.ok(Map.of(
        "commit", "a7b3c"  // ← UPDATE THIS
    ));
}
```

### Frontend commit info location:
```typescript
const CommitInfo: React.FC<CommitInfoProps> = ({ className }) => {
  // Hardcoded commit info - update this with each commit/PR to main
  const commitHash = "a7b3c";  // ← UPDATE THIS
```

### Frontend commit display:
- ✅ Show first 5 characters of commit hash
- ✅ Show tooltip with full commit hash
- ✅ Place at bottom of homepage
- ✅ Use consistent styling with Material-UI

### Backend commit API:
- ✅ Endpoint: `GET /api/v1/info/commit`
- ✅ Return only commit hash
- ✅ Use hardcoded value for simplicity

### Update process:
1. **Generate new 5-character hash** (random alphanumeric)
2. **Update commit file** in project root
3. **Update backend**: Modify `AppController.java` commitInfo() method
4. **Update frontend**: Modify `CommitInfo.tsx` component
5. **Test both**: Verify API endpoint and frontend display
6. **Commit changes**: Include commit hash update in commit message

### Enforcement:
- ALWAYS update commit information when committing to main branch
- ALWAYS ensure commit info is visible on frontend
- ALWAYS ensure commit info is accessible via backend API
- ALWAYS maintain consistency between frontend and backend commit info
- NEVER commit without updating commit information
- ALWAYS test commit info display after deployment

## 📝 Documentation Creation Rules
**NEVER create documentation files without explicit user request**

### Required behavior:
- ✅ Only create documentation when user explicitly asks (e.g., "создай документацию", "напиши README", "добавь описание")
- ✅ When fixing bugs or adding features: Just implement the code, don't create docs
- ✅ When making code changes: Focus on functionality, not documentation
- ✅ When user asks for help: Provide code solutions, not documentation files
- ❌ NEVER create *.md files without explicit request
- ❌ NEVER create README files for new features automatically
- ❌ NEVER create documentation "just in case" or "for completeness"

### When to create documentation:
- User says: "создай документацию", "напиши README", "добавь описание"
- User says: "создай руководство", "напиши инструкцию"
- User explicitly requests documentation for specific features
- User asks for API documentation or deployment guides

### When NOT to create documentation:
- After fixing bugs or issues
- After adding new features or functionality
- After making code improvements
- After updating configurations
- When user just asks to "add" or "create" something (code, not docs)
- When providing code solutions or fixes

### Enforcement:
- ALWAYS ask user if they want documentation before creating any *.md files
- ALWAYS focus on code implementation first, documentation second
- ALWAYS respect user's preference for minimal documentation
- NEVER assume user wants documentation for every change
- ALWAYS prioritize working code over comprehensive documentation