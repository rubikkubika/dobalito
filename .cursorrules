# Cursor Rules for Dobalito Project

## üíª Terminal/Shell Rules (CRITICAL - ALWAYS ENFORCE)
**üî¥ MANDATORY: ALWAYS use Git Bash for ALL terminal commands on Windows**
**üî¥ NEVER use PowerShell commands (tasklist, findstr, $env:, etc.)**

### Required shell usage:
- ‚úÖ **MANDATORY**: Use Git Bash: `C:\Program Files\Git\bin\bash.exe` (ONLY shell allowed)
- ‚úÖ Git Bash commands with proper Unix syntax (ps, grep, curl, etc.)
- ‚úÖ Environment variables: `VARIABLE=value` (not `$env:VARIABLE`)
- ‚úÖ Command chaining: `&&` (not `;` from PowerShell)
- ‚úÖ Background processes: `command &` (not `is_background: true`)
- ‚ùå **NEVER** use PowerShell commands: `tasklist`, `findstr`, `$env:`, `Get-Process`
- ‚ùå **NEVER** use `$env:VARIABLE` syntax
- ‚ùå **NEVER** use PowerShell-specific cmdlets
- ‚ùå **NEVER** use Windows CMD commands without Git Bash wrapper

### Git Bash command examples:
```bash
# Backend start (Git Bash)
cd backend && \
SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/dobalito" \
SPRING_DATASOURCE_USERNAME="postgres" \
SPRING_DATASOURCE_PASSWORD="root" \
mvn spring-boot:run &

# Frontend start (Git Bash)
cd frontend-react && npm start &

# Check processes
ps aux | grep -E 'java|node' | grep -v grep

# Port check
netstat -ano | grep ':8080\|:3000\|:3001'

# API check
curl --max-time 10 http://localhost:8080/api/v1/health
```

### Enforcement (AI Assistant MUST follow):
- üî¥ **CRITICAL**: EVERY terminal command MUST use Git Bash wrapper
- üî¥ **CRITICAL**: If you catch yourself typing `tasklist`, `findstr`, `$env:` - STOP and use Git Bash
- ‚úÖ ALWAYS execute commands through Git Bash: `& "C:\Program Files\Git\bin\bash.exe" -c "command"`
- ‚úÖ ALWAYS use Unix-style commands: `ps`, `grep`, `curl`, `kill`
- ‚úÖ ALWAYS use proper bash syntax for env variables: `VARIABLE=value`
- ‚ùå NEVER use PowerShell native commands without Git Bash wrapper
- ‚ùå NEVER switch to PowerShell (even if it seems easier)
- ‚ùå NEVER assume PowerShell is acceptable alternative

### Git Bash invocation in terminal commands:
```bash
# ‚úÖ CORRECT: Always use Git Bash wrapper for ALL commands
& "C:\Program Files\Git\bin\bash.exe" -c "ps aux | grep java"
& "C:\Program Files\Git\bin\bash.exe" -c "netstat -ano | grep 8080"
& "C:\Program Files\Git\bin\bash.exe" -c "curl --max-time 10 http://localhost:8080/api/v1/health"

# ‚ùå WRONG: Never use PowerShell commands directly
# tasklist | findstr java.exe  # ‚Üê FORBIDDEN
# netstat -ano | findstr :8080  # ‚Üê FORBIDDEN
# $env:VARIABLE="value"  # ‚Üê FORBIDDEN
```

### Git Bash command replacements (MANDATORY):
- `tasklist` ‚Üí `& "C:\Program Files\Git\bin\bash.exe" -c "ps aux"`
- `findstr` ‚Üí `& "C:\Program Files\Git\bin\bash.exe" -c "grep"`
- `netstat -ano | findstr` ‚Üí `& "C:\Program Files\Git\bin\bash.exe" -c "netstat -ano | grep"`
- `Get-Process` ‚Üí `& "C:\Program Files\Git\bin\bash.exe" -c "ps aux"`
- `$env:VAR` ‚Üí Use Git Bash: `VARIABLE=value command`

## üê≥ Docker Files Organization (STRICT RULE)
**ALL Docker-related files MUST be placed in the `docker/` directory**

### Required Placement:
- ‚úÖ `docker/docker-compose.yml` - Main compose file
- ‚úÖ `docker/Dockerfile.frontend` - Frontend Dockerfile  
- ‚úÖ `docker/Dockerfile.backend` - Backend Dockerfile
- ‚úÖ `docker/Dockerfile.fullstack` - Full-stack Dockerfile
- ‚úÖ `docker/nginx.conf` - Nginx configuration
- ‚úÖ `docker/*.sh` - Docker scripts

### Forbidden Placement:
- ‚ùå `docker-compose.yml` (in root)
- ‚ùå `Dockerfile` (in root)
- ‚ùå `nginx.conf` (in root)
- ‚ùå Any Docker files outside `docker/` directory

## üìÅ Project Structure Rules
- Keep Docker configurations centralized in `docker/` folder
- Use `docker/` as build context for Docker operations
- Maintain consistency with existing Docker file organization
- Reference Docker files with paths relative to `docker/` directory

## üîß Build Context Guidelines
When creating Docker configurations:
- Build context: `docker/` directory
- Dockerfile paths: `docker/Dockerfile.*`
- Compose file paths: `docker/docker-compose.*`

## üìù File Naming Conventions
- Docker Compose: `docker-compose.yml`, `docker-compose.*.yml`
- Dockerfiles: `Dockerfile`, `Dockerfile.*`
- Config files: descriptive names (`nginx.conf`, `postgres.conf`)

## ‚ö†Ô∏è Enforcement
- Always place new Docker files in `docker/` directory
- Update build contexts when referencing Docker files
- Maintain existing Docker file organization patterns

## üåê HTTP Client Rules
**ALWAYS use timeout with curl commands**

### Required curl usage:
- ‚úÖ `curl.exe --max-time 10 -s http://localhost:3001` (Windows PowerShell)
- ‚úÖ `curl --max-time 10 -s http://localhost:3001` (Linux/Mac)
- ‚úÖ `curl.exe --connect-timeout 5 --max-time 10 -s http://localhost:8080/api/v1/health`
- ‚ùå `curl http://localhost:3001` (no timeout)
- ‚ùå `curl -s http://localhost:3001` (no timeout)

### Timeout guidelines:
- `--connect-timeout 5` - Connection timeout (5 seconds)
- `--max-time 10` - Total timeout (10 seconds)
- Always use `-s` for silent mode
- Use `-f` for fail on HTTP errors when needed
- On Windows PowerShell, use `curl.exe` instead of `curl`

## üîÑ Service Restart Rules
**ALWAYS check what's running first, then restart accordingly**

### MANDATORY restart sequence (NEVER skip steps):
1. **Check local processes**: 
   - Windows: `tasklist | findstr java.exe` AND `tasklist | findstr node.exe`
   - Linux/Mac: `ps aux | grep java` AND `ps aux | grep node`
2. **Check Docker containers**: `docker-compose -f docker/docker-compose.yml ps`
3. **Check port usage**: `netstat -ano | findstr :8080` (Windows) or `lsof -i :8080` (Linux/Mac)
4. **Stop ALL conflicting processes**:
   - If restarting locally: `docker-compose -f docker/docker-compose.yml down`
   - If restarting via Docker: `taskkill /f /im java.exe` AND `taskkill /f /im node.exe`
5. **Start services based on request**:
   - For local backend restart: Create local DB + `cd backend; $env:SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/dobalito"; $env:SPRING_DATASOURCE_USERNAME="postgres"; $env:SPRING_DATASOURCE_PASSWORD="root"; mvn spring-boot:run`
   - For Docker restart: `docker-compose -f docker/docker-compose.yml up -d`
6. **MANDATORY verification**: 
   - Wait 15-20 seconds for startup
   - Test with curl: `curl.exe --max-time 10 -s http://localhost:8080/api/v1/health`
   - Verify port is listening: `netstat -ano | findstr :8080`

### Context-aware restart:
- **"–∑–∞–ø—É—Å—Ç–∏ –±—ç–∫ –ª–æ–∫–∞–ª—å–Ω–æ"** ‚Üí Stop Docker, start locally with Maven + local DB
- **"–∑–∞–ø—É—Å—Ç–∏ —Ñ—Ä–æ–Ω—Ç –ª–æ–∫–∞–ª—å–Ω–æ"** ‚Üí Stop Docker, start locally with npm
- **"–ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏ —Å–µ—Ä–≤–∏—Å—ã —á–µ—Ä–µ–∑ docker"** ‚Üí Stop local processes, start Docker
- **"–ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏ —Å–µ—Ä–≤–∏—Å—ã"** ‚Üí Check what's running, restart accordingly

## üè† Local Backend Database Rules
**When user requests "–∑–∞–ø—É—Å—Ç–∏—Ç—å –±—ç–∫ –ª–æ–∫–∞–ª—å–Ω–æ" or "–∑–∞–ø—É—Å—Ç–∏—Ç—å –±—ç–∫–µ–Ω–¥ –ª–æ–∫–∞–ª—å–Ω–æ":**

### MANDATORY local database setup:
1. **ALWAYS use local PostgreSQL database `dobalito`**
2. **Connection string**: `jdbc:postgresql://localhost:5432/dobalito`
3. **Credentials**: username=`postgres`, password=`root`
4. **Create database if not exists**:
   ```bash
   $env:PGPASSWORD="root"; & "C:\Program Files\PostgreSQL\18\bin\psql.exe" -U postgres -h localhost -c "CREATE DATABASE dobalito;"
   ```
5. **Start backend with local DB**:
   ```bash
   cd backend; $env:SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/dobalito"; $env:SPRING_DATASOURCE_USERNAME="postgres"; $env:SPRING_DATASOURCE_PASSWORD="root"; mvn spring-boot:run
   ```

### CRITICAL requirements:
- ‚úÖ ALWAYS create `dobalito` database if it doesn't exist
- ‚úÖ ALWAYS use local PostgreSQL (not Docker database)
- ‚úÖ ALWAYS set environment variables for local DB connection
- ‚úÖ ALWAYS run Maven from backend directory
- ‚úÖ ALWAYS verify local database connection before starting
- ‚ùå NEVER use Docker database for local backend runs
- ‚ùå NEVER assume database exists without checking/creating

### CRITICAL requirements:
- ‚úÖ ALWAYS check BOTH Java AND Node processes
- ‚úÖ ALWAYS check Docker containers status
- ‚úÖ ALWAYS check port conflicts (8080, 3000, 3001)
- ‚úÖ ALWAYS stop conflicting processes BEFORE starting
- ‚úÖ ALWAYS wait for startup completion (15-20 seconds)
- ‚úÖ ALWAYS verify with curl requests
- ‚úÖ ALWAYS confirm port is listening
- ‚ùå NEVER assume services are running without verification
- ‚ùå NEVER skip process checking steps
- ‚ùå NEVER start services without stopping conflicts first

### Maven/Node.js specific rules:
- **Maven commands**: Run from current directory (assumes backend/ is current)
- **PowerShell syntax**: Use `;` instead of `&&` for command chaining
- **Background processes**: Use `is_background: true` for long-running commands
- **Error handling**: If Maven fails, check pom.xml and dependencies
- **Port conflicts**: Always verify port 8080 is free before starting backend
- **Directory assumption**: Assume current directory is backend/ when running Maven

### Enforcement:
- MANDATORY: Complete all 6 steps in sequence
- MANDATORY: Verify service availability after each restart
- MANDATORY: Report status clearly to user
- MANDATORY: Follow user's explicit restart preference (local vs Docker)
- MANDATORY: Use correct PowerShell syntax (no `&&` operators)
- MANDATORY: Run Maven from current directory (assume backend/)

## üöÄ Local Development Rules
**ALWAYS run npm start in background to avoid blocking chat**

### Required npm start usage:
- ‚úÖ `npm start` (with is_background: true) - Run in background
- ‚úÖ `Start-Job -ScriptBlock { npm start }` (PowerShell) - Background job
- ‚úÖ `nohup npm start > npm.log 2>&1 &` (Linux/Mac) - Background with logs
- ‚ùå `npm start` (with is_background: false) - Blocks chat and terminal

### Why background execution:
- ‚úÖ Prevents chat blocking during development
- ‚úÖ Allows continued interaction with assistant
- ‚úÖ Enables parallel command execution
- ‚úÖ Maintains development workflow continuity

### Enforcement:
- NEVER run npm start in foreground mode
- ALWAYS use is_background: true for npm start commands
- ALWAYS verify service availability after background start
- Use Docker as preferred development environment when possible

## üîß Local Backend Logging Rules
**Smart backend startup: logs first, then background mode**

### CRITICAL: Backend startup strategy:
- ‚úÖ **FIRST RUN**: Use `is_background: false` to show startup logs and diagnose issues
- ‚úÖ **AFTER SUCCESS**: Switch to `is_background: true` for continued development
- ‚úÖ **ON ERRORS**: Always use `is_background: false` to see error details
- ‚úÖ **MANDATORY**: Show full Spring Boot logs for initial diagnosis
- ‚úÖ **MANDATORY**: Display Flyway migration logs
- ‚úÖ **MANDATORY**: Show JPA/Hibernate startup logs
- ‚úÖ **MANDATORY**: Display database connection logs

### Why this approach works:
- ‚úÖ **Initial diagnosis**: See all startup logs to catch issues early
- ‚úÖ **Interactive development**: Switch to background after successful startup
- ‚úÖ **Error visibility**: Always show logs when problems occur
- ‚úÖ **Development flow**: Maintain chat interactivity during normal development

### Smart backend startup pattern:
```bash
# ‚úÖ STEP 1 - Initial startup with logs (for diagnosis)
run_terminal_cmd
  command: cd backend; $env:SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/dobalito"; $env:SPRING_DATASOURCE_USERNAME="postgres"; $env:SPRING_DATASOURCE_PASSWORD="root"; mvn spring-boot:run
  is_background: false  # ‚Üê Show logs for diagnosis

# ‚úÖ STEP 2 - After successful startup, restart in background
run_terminal_cmd
  command: cd backend; $env:SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/dobalito"; $env:SPRING_DATASOURCE_USERNAME="postgres"; $env:SPRING_DATASOURCE_PASSWORD="root"; mvn spring-boot:run
  is_background: true   # ‚Üê Background for continued development
```

### Exception: Frontend can always run in background:
```bash
# ‚úÖ OK - Frontend can run in background
run_terminal_cmd
  command: cd frontend-react; npm start
  is_background: true  # ‚Üê OK for frontend
```

### Enforcement:
- ALWAYS use `is_background: false` for initial backend startup
- ALWAYS analyze backend logs for errors before proceeding
- ALWAYS switch to `is_background: true` after successful startup
- ALWAYS use `is_background: false` when errors occur
- NEVER hide backend startup logs during initial diagnosis

## üåç Internationalization Rules
**ALWAYS update translations for both languages when modifying frontend elements**

### Required i18n workflow:
- ‚úÖ When adding new text elements: Add translations to `LanguageContext.tsx` for both `ru` and `en`
- ‚úÖ When modifying existing text: Update both language versions in `LanguageContext.tsx`
- ‚úÖ When creating new pages: Use `useLanguage()` hook and `t()` function for all text
- ‚úÖ When updating UI components: Ensure all hardcoded text uses translation keys
- ‚ùå Never add hardcoded Russian/English text directly in components
- ‚ùå Never update only one language without updating the other

### Translation key structure:
- **Navigation**: `nav.*` (nav.home, nav.profile, nav.settings, nav.designs)
- **Home page**: `home.*` (home.welcome, home.subtitle, home.categories, home.features)
- **Categories**: `category.*` (category.surfing, category.bike_rental)
- **Features**: `feature.*` (feature.create_tasks, feature.find_executors, etc.)
- **Executors**: `executors.*` (executors.title, executors.back, executors.empty)
- **Language selector**: `lang.*` (lang.russian, lang.english)

### Required implementation pattern:
```typescript
// ‚úÖ CORRECT - Using translations
const { t } = useLanguage();
<Typography>{t('home.welcome')}</Typography>

// ‚ùå WRONG - Hardcoded text
<Typography>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ doBalito</Typography>
```

### LanguageContext.tsx structure:
```typescript
const translations = {
  ru: {
    'key.name': 'Russian text',
    // ... all Russian translations
  },
  en: {
    'key.name': 'English text',
    // ... all English translations
  },
};
```

### Enforcement:
- ALWAYS add new translation keys to both `ru` and `en` objects
- ALWAYS use `t()` function instead of hardcoded text
- ALWAYS test both language versions when making changes
- ALWAYS maintain consistent translation key naming
- NEVER leave incomplete translations (missing keys in one language)

## üö´ Service Auto-Start Rules
**NEVER start services automatically without explicit user request**

### Required behavior:
- ‚úÖ Only start services when user explicitly asks (e.g., "–∑–∞–ø—É—Å—Ç–∏ —Å–µ—Ä–≤–∏—Å—ã", "start services", "–ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏")
- ‚úÖ When creating new entities/features: Just create the code, don't start services
- ‚úÖ When adding dependencies: Just update configuration, don't restart
- ‚úÖ When modifying code: Just make changes, don't auto-restart
- ‚ùå NEVER run `docker-compose up` or `npm start` without user request
- ‚ùå NEVER restart services after code changes unless asked
- ‚ùå NEVER assume user wants services running after modifications

### When to start services:
- User says: "–∑–∞–ø—É—Å—Ç–∏ —Å–µ—Ä–≤–∏—Å—ã", "start services", "–ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏"
- User says: "–∑–∞–ø—É—Å—Ç–∏ —Ñ—Ä–æ–Ω—Ç", "start frontend"
- User says: "–∑–∞–ø—É—Å—Ç–∏ –±—ç–∫–µ–Ω–¥", "start backend"
- User says: "–ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏ —á–µ—Ä–µ–∑ docker", "restart with docker"
- User explicitly requests testing or verification

### When NOT to start services:
- After creating new entities (User, Category, etc.)
- After adding new dependencies
- After modifying existing code
- After creating new controllers/services
- After updating configuration files
- When user just asks to "add" or "create" something

### Enforcement:
- ALWAYS ask user if they want to start services after major changes
- ALWAYS inform user that services are ready but not started
- ALWAYS let user decide when to start/restart services
- NEVER assume user wants immediate service restart
- ALWAYS respect user's development workflow preferences

## üìÅ Temporary Files Management Rules
**ALL temporary files MUST be placed in the `temp/` directory**

### Required Placement:
- ‚úÖ `temp/` - All temporary files and folders
- ‚úÖ `temp/debug/` - Debug files and logs
- ‚úÖ `temp/test/` - Test files and outputs
- ‚úÖ `temp/cookies*.txt` - Cookie files
- ‚úÖ `temp/*.log` - Log files
- ‚úÖ `temp/*.tmp` - Temporary files

### Forbidden Placement:
- ‚ùå Temporary files in project root
- ‚ùå Temporary files in backend/ or frontend-react/
- ‚ùå Temporary files in git-tracked directories
- ‚ùå Log files outside temp/ directory

### Temporary file types:
- **Debug files**: `*.debug`, `*.test`, `*.tmp`
- **Log files**: `*.log`, `*.error.log`, `maven*.log`
- **Cookie files**: `cookies*.txt`, `cookies-after-*.txt`
- **Backup files**: `*.bak`, `*.backup`
- **IDE temp files**: `*.swp`, `*.swo`, `*~`

### Git exclusion:
- All files in `temp/` directory are automatically ignored by git
- Temporary files are never committed to repository
- Clean up temp/ directory regularly

### Enforcement:
- ALWAYS create temporary files in `temp/` directory
- ALWAYS use descriptive subdirectories in `temp/`
- ALWAYS clean up temporary files after debugging
- NEVER commit temporary files to git
- ALWAYS use `temp/` for any development artifacts

## üìö Documentation Management Rules
**ALL documentation files MUST be placed in the `docs/` directory**

### Required Placement:
- ‚úÖ `docs/` - All documentation files
- ‚úÖ `docs/development/` - Development guides and rules
- ‚úÖ `docs/user-guide/` - User documentation and guides
- ‚úÖ `docs/api/` - API documentation
- ‚úÖ `docs/deployment/` - Deployment guides
- ‚úÖ `docs/architecture/` - System architecture docs

### Forbidden Placement:
- ‚ùå Documentation files in project root
- ‚ùå Documentation files in backend/ or frontend-react/
- ‚ùå README files outside docs/ (except main README.md)
- ‚ùå Documentation scattered across different directories

### Documentation file types:
- **Guides**: `*.md`, `*.rst`, `*.txt`
- **API docs**: `api-*.md`, `swagger-*.md`
- **Architecture**: `architecture-*.md`, `design-*.md`
- **Deployment**: `deploy-*.md`, `setup-*.md`
- **User guides**: `user-*.md`, `guide-*.md`

### Documentation structure:
```
docs/
‚îú‚îÄ‚îÄ README.md              # Main documentation index
‚îú‚îÄ‚îÄ development/           # Development guides
‚îÇ   ‚îú‚îÄ‚îÄ development-rules.md
‚îÇ   ‚îú‚îÄ‚îÄ local-backend-rule.md
‚îÇ   ‚îî‚îÄ‚îÄ coding-standards.md
‚îú‚îÄ‚îÄ user-guide/           # User documentation
‚îÇ   ‚îú‚îÄ‚îÄ user-rules.md
‚îÇ   ‚îî‚îÄ‚îÄ getting-started.md
‚îú‚îÄ‚îÄ api/                  # API documentation
‚îÇ   ‚îú‚îÄ‚îÄ api-reference.md
‚îÇ   ‚îî‚îÄ‚îÄ endpoints.md
‚îú‚îÄ‚îÄ deployment/           # Deployment guides
‚îÇ   ‚îú‚îÄ‚îÄ docker-deployment.md
‚îÇ   ‚îî‚îÄ‚îÄ production-setup.md
‚îî‚îÄ‚îÄ architecture/         # System architecture
    ‚îú‚îÄ‚îÄ system-overview.md
    ‚îî‚îÄ‚îÄ database-schema.md
```

### Git inclusion:
- All files in `docs/` directory are tracked by git
- Documentation is part of the project repository
- Keep documentation up-to-date with code changes

### Enforcement:
- ALWAYS create documentation files in `docs/` directory
- ALWAYS use appropriate subdirectories in `docs/`
- ALWAYS update documentation when making code changes
- ALWAYS maintain consistent documentation structure
- NEVER create documentation files outside `docs/`
- ALWAYS reference documentation from `docs/` in code comments

## üîÑ Commit Information Update Rules
**ALWAYS update commit information when making commits or PRs to main branch**

### Required commit info updates:
- ‚úÖ Update `commit` file in project root with new 5-character hash
- ‚úÖ Update hardcoded commit hash in `backend/src/main/java/com/dobalito/controller/AppController.java` method `commitInfo()`
- ‚úÖ Update hardcoded commit hash in `frontend-react/src/components/CommitInfo.tsx` component
- ‚úÖ Ensure commit hash is visible on frontend homepage
- ‚úÖ Ensure commit hash is accessible via backend API `/api/v1/info/commit`

### Commit file location:
```
commit  # ‚Üê UPDATE THIS FILE with new 5-character hash
```

### Backend commit info location:
```java
@GetMapping("/info/commit")
public ResponseEntity<?> commitInfo() {
    return ResponseEntity.ok(Map.of(
        "commit", "a7b3c"  // ‚Üê UPDATE THIS
    ));
}
```

### Frontend commit info location:
```typescript
const CommitInfo: React.FC<CommitInfoProps> = ({ className }) => {
  // Hardcoded commit info - update this with each commit/PR to main
  const commitHash = "a7b3c";  // ‚Üê UPDATE THIS
```

### Frontend commit display:
- ‚úÖ Show first 5 characters of commit hash
- ‚úÖ Show tooltip with full commit hash
- ‚úÖ Place at bottom of homepage
- ‚úÖ Use consistent styling with Material-UI

### Backend commit API:
- ‚úÖ Endpoint: `GET /api/v1/info/commit`
- ‚úÖ Return only commit hash
- ‚úÖ Use hardcoded value for simplicity

### Update process:
1. **Generate new 5-character hash** (random alphanumeric)
2. **Update commit file** in project root
3. **Update backend**: Modify `AppController.java` commitInfo() method
4. **Update frontend**: Modify `CommitInfo.tsx` component
5. **Test both**: Verify API endpoint and frontend display
6. **Commit changes**: Include commit hash update in commit message

### Enforcement:
- ALWAYS update commit information when committing to main branch
- ALWAYS ensure commit info is visible on frontend
- ALWAYS ensure commit info is accessible via backend API
- ALWAYS maintain consistency between frontend and backend commit info
- NEVER commit without updating commit information
- ALWAYS test commit info display after deployment

## üìù Documentation Creation Rules
**NEVER create documentation files without explicit user request**

### Required behavior:
- ‚úÖ Only create documentation when user explicitly asks (e.g., "—Å–æ–∑–¥–∞–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é", "–Ω–∞–ø–∏—à–∏ README", "–¥–æ–±–∞–≤—å –æ–ø–∏—Å–∞–Ω–∏–µ")
- ‚úÖ When fixing bugs or adding features: Just implement the code, don't create docs
- ‚úÖ When making code changes: Focus on functionality, not documentation
- ‚úÖ When user asks for help: Provide code solutions, not documentation files
- ‚ùå NEVER create *.md files without explicit request
- ‚ùå NEVER create README files for new features automatically
- ‚ùå NEVER create documentation "just in case" or "for completeness"

### When to create documentation:
- User says: "—Å–æ–∑–¥–∞–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é", "–Ω–∞–ø–∏—à–∏ README", "–¥–æ–±–∞–≤—å –æ–ø–∏—Å–∞–Ω–∏–µ"
- User says: "—Å–æ–∑–¥–∞–π —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ", "–Ω–∞–ø–∏—à–∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é"
- User explicitly requests documentation for specific features
- User asks for API documentation or deployment guides

### When NOT to create documentation:
- After fixing bugs or issues
- After adding new features or functionality
- After making code improvements
- After updating configurations
- When user just asks to "add" or "create" something (code, not docs)
- When providing code solutions or fixes

### Enforcement:
- ALWAYS ask user if they want documentation before creating any *.md files
- ALWAYS focus on code implementation first, documentation second
- ALWAYS respect user's preference for minimal documentation
- NEVER assume user wants documentation for every change
- ALWAYS prioritize working code over comprehensive documentation